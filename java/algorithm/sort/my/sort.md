# 정렬

## 힙정렬

힙을 이용해 최대, 최소값을 찾는 정렬 방법
힙: 1) 완전이진트리 기반 2) partial order 만족
최대값을 구할 경우, 배열을 최대힙으로 만들어주면 루트 노드는 가장 큰 값을 갖게 된다.
배열의 마지막 값과 루트노드와 바꿔주고 업데이트된 루트노드를 다운힙(아래로 내리면서 정렬) 진행
결국 루트로 최대값이 올라올 수밖에 없고, 가장 큰 것으로 확인된 요소는 배열에서 없다고 가정하면서 정렬을 진행하게 됨. 최소값은 최소힙으로 만들면 된다.

## 선택정렬

배열의 첫 번째 위치에서 시작해 나열된 값 중 최소값을 구해 앞으로 이동
그 다음 두 번째 위치에서 시작해 오른쪽 값들 중 최소값을 앞으로 이동
위 과정을 배열의 길이 n까지 계속 반복하면서 마지막 값까지 진행하면 정렬 완료
배열의 길이가 작으면 속도가 빠르지만, 길이가 길 수록 속도가 급격히 하락

카운팅 정렬은 수많은 정렬 알고리즘 중 시간복잡도가 O(n)으로 엄청난 성능을 보여주는 알고리즘이다. 보통 빠르다는 정렬 알고리즘으로는 대표적으로 퀵 정렬(Quick Sort),
힙 정렬(Heap Sort), 합병 정렬(Merger Sort) 등이 있는데, 이들의 평균 시각복잡도는 O(nlogn)인 것에 비하면 엄청난 속도다.
기본적으로 정렬이라하면 데이터끼리 직접 비교하는 경우가 많다. 그렇기 때문에 데이터 직접 비교를 사용하는 정렬 알고리즘의 경우 O(nlogn)보다 작아질 수 없는 것이 한계다.

카운팅 정렬의 기본 매커니즘은 아주 단순하다. 데이터의 값이 몇 번 나왔는지를 세주는 것이다. 말 그대로 counting 하는 것이다.
array를 한 번 순회하면서 각 값이 나올 때마다 해당 값을 index로 하는 새로운 배열의 값을 1증가시킨다.

과정으로 보면
array[0] = 7 이므로 counting[7] 값을 1증가,
array[1] = 2 이므로 counting[2] 값을 1증가,
...
array[11] = 1 이므로 count[1] 값을 1증가.

이렇게 과정을 거친다. 이 과정을 마치면 다음 그림처럼 된다.

## 버블정렬

배열의 첫번째 위치에서 인접한(바로 옆의)값과 비교해 큰 값을 오른쪽으로 이동
n-1번째까지 한바퀴를 돌게 되면 최대값은 배열의 맨 마지막으로 가게 되어있음
그 다음 배열의 첫번째에서 n-2까지 비교, 인덱스를 줄여가면서 비교해 정렬

거품 정렬은 아마 정렬 방식 중 가장 쉽게 생각할 수 있는 알고리즘 중 하나이다.
두 개의 인접한 원소를 비교하여 정렬하는 방식이다.
왜 Bubble 이라는 이름이 붙었는지 찾아보니 정렬 과정에서 원소의 이동이 마치 거품이 수면위로 올라오는 것 같다고 해서 거품 (Bubble) 이라는 이름이 붙었다고 한다.

거품 정렬은 데이터를 '비교'하면서 찾기 떄문에 '비교 정렬'이며 정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지 않기 때문에 '제자리 정렬(in-place sort)'이기도 하다.
정확히는 데이터를 서로 교환하는 과정(swap)에서 임시 변수를 필요로 하나, 이는 충분히 무시할 만큼 적은 양이기 때문에 제자리 정렬로 보는 것이다. 이는 선택정렬과도 같은 부분이다.
그리고 이전에 다뤘던 선택 정렬과는 달리 거품 정렬은 앞에서부터 차례대로 비교하기 때문에 '안정 정렬'이기도 한다.

1. 앞에서부터 현재 원소와 바로 다음의 원소를 비교한다.
2. 현재 원소가 다음 원소보다 크면 원소를 교환한다.
3. 다음 원소로 이동하여 해당 원소와 그 다음원소를 비교한다.


```java

public class Bubble_sort {
    public static void bubble_sort(int[] a) {
        bubble_sort(a, a.length);
    }
    
    public static void bubble_sort(int[] a,int size) {
        for (int i=1; i<size; i++) {
            for (int j=0; j<size - i; j++) {
                if (a[j] > a[j+1]) {
                    swap(a, j, j+1);
                }
            }
        }
    }
    
    private static void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}

```

## 삽입정렬

배열이 어느정도 정렬된 상태에서 사용한다.
정렬이 되어있지 않은 배열의 모든 요소를 정렬된 배열과 비교하여, 들어갈 위치를 찾고 그 위치에 삽입한다.
정렬이 필요할 때만 연산하기 때문에 빠르다

현재 비교하고자 하는 target과 그 이전의 원소들과 비교하며 자리를 교환하는 정렬 방법이다.
삽입 정렬은 데이터를 '비교'하면서 찾기 때문에 '비교 정렬'이며 정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지 않기 때문에 '제자리 정렬'이기도 하다.
정확히는 데이터를 서로 교환하는 과정에서 임시 변수를 필요로 하나, 이는 충분히 무시할 만큼 적은 양이기 떄문에 제자리 정렬로 본다.
삽입 정렬은 '안정 정렬'이다.

1. 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들들 비교한다.(첫 번째 타켓은 두 번째 원소부터 시작하낟.)
2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.
3. 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다.

```java

  public class Insertion_sort {
    public static void insertion_sort(int[] a) {
        insertion_sort(a, a.length);
    }
    
    private static void insertion_sort(int[] a, int size) {
        for (int i =1; i<size; i++) {
            int target = a[i];
            
            int j = i -1;
            
            while (j >= 0 && target < a[j]) {
                a[j+1] = a[j];
                j--;
            }
            
            a[j+1] = target;
        }
    }
  }
```

## 합병(병합)정렬

분할정복(Divide and Conquer) 알고리즘의 일종
배열의 가장 최소단위가 1이 될 때까지 분할하고, 다시 합치면서 값을 비교하며 정렬함
분할하면서 추가적 배열이 필요하게 되고, 메모리가 소요되어 공간복잡도 효율은 떨어짐
합칠 때 이미 자기 자신은 정렬이 되어있기 때문에, 앞의 값을 기준으로 분리되어 있는 다른 값끼리만 비교하면 됨
- ex) [6,7][5,8] 을 비교하면 이미 배열 안은 정렬되어있으므로 6과 5,8만 비교하면 최소값 바로 확인 가능

## 퀵정렬

- 퀵 정렬은 불안정 정렬 에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬 에 속한다.
- 분할 정복 알고리즘의 하나로, 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법
  - 합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 비균등하게 분할한다.
- 분할 정복(divide and conquer) 방법
  - 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
  - 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.
- 과정 설명
  - 리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
  - 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다. (피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)
  - 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
    - 분할된 부분 리스트에 대하여 순환 호출 을 이용하여 정렬을 반복한다.
    - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
  - 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
    - 리스트의 크기가 0이나 1이 될 때까지 반복한다.
-----
- 하나의 리스트를 피벗(pivot)을 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.
퀵 정렬은 다음의 단계들로 이루어진다.
  - 분할(Divide): 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할한다.
  - 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
  - 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.
  순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.

- 시간복잡도

![image](https://gmlwjd9405.github.io/images/algorithm-quick-sort/sort-time-complexity.png)

## 삽입정렬

삽입 정렬은 현재 비교하고자 하는 target과 그 이전의 원소들과 비교하며 자리를 교환(swap)하는 정렬 방법
삽입 정렬은 데이터를 '비교'하면서 찾기 때문에 '비교 정렬'이며 정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지 않기 때문에 '제자리 정렬'이기도 하다.
정확히는 데이터를 서로 교환하는 과정에서 임시 변수를 필요로 하나, 이는 충분히 무시할 만큼 적은 양이기 때문에 제자리 정렬로 본다. 이는 선택정렬과도 같은 부분이다.

- 정렬 방법(오름차순)
  - 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들을 비교한다.(첫 번째 타켓은 두번째 원소부터 시작한다.)
  - 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.
  - 그 다음 타겟으 찾아 위와 같은 방법으로 반복한다.

```java
  public class Insertion_Sort {
    public static void insertion_sort(int[] a){
        insertion_sort(a, a.length);
    }
    
    private static void insertion_sort(int[] a, int size) {
        for (int i =1; i<size; i++) {
            int target = a[i];
            
            int j = j -1;
            
            while (j >= 0 && target < a[j]) {
                a[j+1] = a[j];
                j--;
            }
            
            a[j+1] = target;
        }
    }
}

```

- 삽입 정렬의 장점 및 단점

[장점]
1. 추가적인 메모리 소비가 작다.
2. 거의 정렬 된 경우 매우 효율적이다. 즉, 최선의 경우 O(N)의 시간복잡도를 갖는다.
3. 안장정렬이 가능하다

[단점]
1. 역순에 가까울 수록 매우 비효율적이다. 즉, 최악의 경우 O(N 제곱)의 시간복잡도를 갖는다.
2. 데이터의 상태에 따라서 성능 편차가 매우 크다.

## 셸정렬

Shell Sort Donald Shell에 고안된 정렬 방법으로 Shell 이라는 이름이 붙었다.
Insertion Sort(삽입 정렬)의 장점을 살리면서 단점은 줄인 방식.
삽입 정렬의 단점을 최소화 하는 것?

삽입 정렬의 단점은 오름차순 기준으로 타겟 원소가 이전의 원소보다 작을 경우 이전 원소들을 모두 교환(swap)한다. 그럼 이 과정을 줄이면?
즉, 이전의 원소를 모두 비교, 교환하는 것이 아니라 일정 간격 주기로 띄엄띄엄 검사하면서 교환하여 타겟 원소의 위치를 대략적으로 잡아주는 것.
그리고 위와 같은 과정을 '간격을 줄여가면서' 정렬해나가다보면 정렬기준에 가까워진다. 그러면 삽입정렬의 장점인 거의 정렬 된 상태일 경우 정렬
속도가 빠르다는 이점 또한 가져갈 수 있다.

쉽게말해 정렬하고자 하는 원소가 10개가 있을 때 간격을 3으로 설정하여 간격이 4인 원소들끼리 삽입정렬을 하고 그 다음 간격을 2로 조정하여 2칸씩 
떨어진 원소들끼리 삽입정렬을 하고, 최종적으로 간격이 1인 즉, 우리가 알고있는 기본적인 삽입정렬을 하는 것이다. 이러한 과정을 거치는 것이 바로
셀 정렬이다.

1. 간격을 설정한다.
2. 각 간격별로 분류 된 서브(부분) 리스트에 대해 삽입정렬을 한다.
3. 각 서브(부분) 리스트의 정렬이 끝나면 간격을 줄인다.
4. 간격이 1이 될 때 까지 2번 과정으로 되돌아가며 반복한다.

간격(gap)이 너무 적으면 건너 뛰는 간격이 적다는 것, 즉 pass 속도가 느려지고, 반대로 간격이 너무 많으면 오버헤드가 발생한다.

```java
public class Shell_Sort {
	
	private final static int[] gap = 
		{ 1, 4, 10, 23, 57, 132, 301, 701, 1750, 3937, 	
		8858, 19930, 44842, 100894, 227011, 510774,
		1149241, 2585792, 5818032, 13090572, 29453787, 
		66271020, 149109795, 335497038, 754868335, 1698453753};	// 갭을 담고있는 배열	
 
	
	public static void shell_sort(int[] a) {
		shell_sort(a, a.length);
		
	}
 
	// 맨 처음 gap을 참조 할 인덱스를 구하는 메소드
	private static int getGap(int length) {
		int index = 0;
		// 최소한 부분 배열의 원소가 2개씩은 비교 되도록 나눠준다.
		int len = (int)(length / 2.25);	
		while (gap[index] <= len) {
			index++;
		}
		return index;
	}
 
	private static void shell_sort(int[] a, int size) {
		int index = getGap(size);	// 첫 gap을 사용할 index
 
		// gap[index] 값부터 gap[0] 까지 반복한다.
		for (int i = index; i >= 0; i--) {
 
			for (int j = 0; j < gap[i]; j++) {	// 각 부분 리스트에 대해 삽입정렬을 한다.
				insertion_sort(a, i, size, gap[i]);
			}
		}
	}
 
	/**
	 * 
	 * @param a		 배열
	 * @param start	 부분 배열의 첫 번째 원소 인덱스 
	 * @param size	 배열의 전체 크기
	 * @param gap	 현재 gap
	 */
	private static void insertion_sort(int[] a, int start, int size, int gap) {
 
		// 부분 배열의 두 번째 원소부터 size까지 반복한다. (gap 값씩 건너띔) 
		for (int i = start + gap; i < size; i += gap) {
 
			int target = a[i];
			int j = i - gap;
 
			// 타겟 원소가 이전의 원소보다 작을 때 까지 반복 
			while (j >= start && target < a[j]) {
				a[j + gap] = a[j];	// 이전 원소를 한 칸씩 뒤로 미룬다.
				j -= gap;
			}
			/*
			 * 위 반복문에서 탈출 하는 경우 앞의 원소가 타겟보다 작다는 의미이므로
			 * 타겟 원소는 j번째 원소 뒤에 와야한다.
			 * 그러므로 타겟은 j + gap 에 위치하게 된다.
			 */
			a[j + gap] = target;
 
		}
	}
}
```


```java
public class Shell_Sort {
	
	private final static int[] gap = 
		{ 1, 4, 10, 23, 57, 132, 301, 701, 1750, 3937, 	
		8858, 19930, 44842, 100894, 227011, 510774,
		1149241, 2585792, 5818032, 13090572, 29453787, 
		66271020, 149109795, 335497038, 754868335, 1698453753};	// 갭을 담고있는 배열	
 
	
	public static void shell_sort(int[] a) {
		shell_sort(a, a.length);
		
	}
 
	// 맨 처음 gap을 참조 할 인덱스를 구하는 메소드
	private static int getGap(int length) {
		int index = 0;
		// 최소한 부분 배열의 원소가 2개씩은 비교 되도록 나눠준다.
		int len = (int)(length / 2.25);	
		while (gap[index] <= len) {
			index++;
		}
		return index;
	}
	
 	private static void shell_sort(int[] a, int size) {
		int gapIndex = getGap(size);
		
		// 갭이 1이 될 때까지 반복
		while(gapIndex >= 0) {
			int step = gap[gapIndex--];	// 현재 gap(step)
			
			
			/*
			 * --- 삽입 정렬 과정 ---
			 * 
			 * 각 부분리스트의 두 번째 원소의 인덱스 부터 순회한다.
			 * 예로들어 step이 3일 때 arr[0], arr[1], arr[2] 는 
			 * 이전 원소와 비교할 것이 없다.
			 * 그러므로 step부터 순회한다.   
			 */
			for(int i = step; i < size; i++) {
				
				/*
				 *  j는 target 원소가 되며 현재 원소(target) a[j]가 이전 원소 a[j - step]보다
				 *  작을 때 까지 반복한다.
				 */
				for (int j = i; j >= step && a[j] < a[j - step]; j -= step) {
					/*
					 *  현재(target) 원소의 인덱스(j)와 이전의 원소(j-step)의 인덱스에 있는
					 *  원소의 값을 교환한다.
					 */
					swap(a, j, j - step);
				}
			}
		}
	}
 
	private static void swap(int[] a, int i, int j) {
		int swap = a[i];
		a[i] = a[j];
		a[j] = swap;
	}
}
```

[장점]
1. 멀리 있는 원소들끼리 빠르게 비교 및 교환이 이루어진다.
2. 삽입정렬(Insertion Sort), 거품정렬(Bubble Sort)에 비해 정렬 속도가 빠르다.

[단점]
1. 일반적인 삽입정렬에 비해 구현이 까다롭다.
2. gap sequence에 영향을 많이 받으며 적절한 시퀀스를 선택해야 한다.
3. 일정 간격을 두고 원소의 교환이 이루어지기 때문에 안정정렬이 아니다.


"갭 시퀀스에 따라 달라진다."

왜냐하면, 결국 서브 리스트를 어떻게 분할해서 삽입정렬을 하느냐인데 간단히 구해지는 갭 시퀀스는 어떻게든 시간 복잡도를 구할 수 있다만, 오늘처럼 일정한 규칙이 아닌 경험적으로 얻어낸 시퀀스나 복잡한 수식에 의해 얻어낸 시퀀스의 경우 그 분석이 매우 어렵다.





다만, 이상적으로 최상의 경우나 최악의 경우는 구할 수 있다.

최상의 경우는 이미 정렬 된 상태이면서, gap sequence가 현재 리스트의 크기를 2n 으로 나눌 수 있을 때다. 그러면 삽입정렬 과정에서 이전의 데이터를 한 번만 비교 한 뒤 더이상 비교하지 않기 때문에 사실상 리스트의 원소를 탐색하는 과정이 시간복잡도가 된다.



쉽게 생각해보면 리스트의 크기가 N일 때 이분탐색처럼 N/2 + N/4 + N/8 + ⋯ + 1 이다.

그러면 연산횟수가 x라고 할 때 N이 1일 경우 1에서 2를 x번 곱해야 한다. 즉, N = 1 × 2x 방정식이 나오고, x를 구하기 위해 양변에 로그를 취해 log2N = xlog22 를 만들어 다시 풀면 logN = x 가 된다.



여기서 위 logN 는 특정 값에 다다르기 위한 x이고, 이 과정을 정렬에서는 모든 원소가 한 번씩 해야하기 때문에 logN 이 N번 반복되므로 시간 복잡도는 O(NlogN) 이 된다는 정도다.





최악의 경우는 gap이 1이고 삽입정렬의 가장 단점이였던 '역순으로 된 리스트' 일 경우이므로. 한 마디로 그냥 삽입 정렬과 똑같으면서 최악의 경우를 생각하면 된다. 당연 O(N2)의 시간 복잡도를 갖는다.



하지만 gap을 1로 사용하면 삽입정렬과 다를게 없기 때문에 일반적인 gap sequence에서는 이 또한 얘기가 달라진다.



정리하자면 일반적으로 시간복잡도는 구하기 매우 까다롭고 어려우며 갭 시퀀스에 따라 의존적이다.

### 갭 시퀀스

A003462
A108870
A102549