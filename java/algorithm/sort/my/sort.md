# 정렬

## 힙정렬

힙을 이용해 최대, 최소값을 찾는 정렬 방법
힙: 1) 완전이진트리 기반 2) partial order 만족
최대값을 구할 경우, 배열을 최대힙으로 만들어주면 루트 노드는 가장 큰 값을 갖게 된다.
배열의 마지막 값과 루트노드와 바꿔주고 업데이트된 루트노드를 다운힙(아래로 내리면서 정렬) 진행
결국 루트로 최대값이 올라올 수밖에 없고, 가장 큰 것으로 확인된 요소는 배열에서 없다고 가정하면서 정렬을 진행하게 됨. 최소값은 최소힙으로 만들면 된다.

## 선택정렬

배열의 첫 번째 위치에서 시작해 나열된 값 중 최소값을 구해 앞으로 이동
그 다음 두 번째 위치에서 시작해 오른쪽 값들 중 최소값을 앞으로 이동
위 과정을 배열의 길이 n까지 계속 반복하면서 마지막 값까지 진행하면 정렬 완료
배열의 길이가 작으면 속도가 빠르지만, 길이가 길 수록 속도가 급격히 하락

## 버블정렬

배열의 첫번째 위치에서 인접한(바로 옆의)값과 비교해 큰 값을 오른쪽으로 이동
n-1번째까지 한바퀴를 돌게 되면 최대값은 배열의 맨 마지막으로 가게 되어있음
그 다음 배열의 첫번째에서 n-2까지 비교, 인덱스를 줄여가면서 비교해 정렬

## 삽입정렬

배열이 어느정도 정렬된 상태에서 사용한다.
정렬이 되어있지 않은 배열의 모든 요소를 정렬된 배열과 비교하여, 들어갈 위치를 찾고 그 위치에 삽입한다.
정렬이 필요할 때만 연산하기 때문에 빠르다

## 합병(병합)정렬

분할정복(Divide and Conquer) 알고리즘의 일종
배열의 가장 최소단위가 1이 될 때까지 분할하고, 다시 합치면서 값을 비교하며 정렬함
분할하면서 추가적 배열이 필요하게 되고, 메모리가 소요되어 공간복잡도 효율은 떨어짐
합칠 때 이미 자기 자신은 정렬이 되어있기 때문에, 앞의 값을 기준으로 분리되어 있는 다른 값끼리만 비교하면 됨
- ex) [6,7][5,8] 을 비교하면 이미 배열 안은 정렬되어있으므로 6과 5,8만 비교하면 최소값 바로 확인 가능

## 퀵정렬

- 퀵 정렬은 불안정 정렬 에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬 에 속한다.
- 분할 정복 알고리즘의 하나로, 평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법
  - 합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 비균등하게 분할한다.
- 분할 정복(divide and conquer) 방법
  - 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.
  - 분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.
- 과정 설명
  - 리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
  - 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다. (피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)
  - 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
    - 분할된 부분 리스트에 대하여 순환 호출 을 이용하여 정렬을 반복한다.
    - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
  - 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
    - 리스트의 크기가 0이나 1이 될 때까지 반복한다.
-----
- 하나의 리스트를 피벗(pivot)을 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 방법이다.
퀵 정렬은 다음의 단계들로 이루어진다.
  - 분할(Divide): 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할한다.
  - 정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
  - 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.
  순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.

- 시간복잡도

![image](https://gmlwjd9405.github.io/images/algorithm-quick-sort/sort-time-complexity.png)

## 삽입정렬

삽입 정렬은 현재 비교하고자 하는 target과 그 이전의 원소들과 비교하며 자리를 교환(swap)하는 정렬 방법
삽입 정렬은 데이터를 '비교'하면서 찾기 때문에 '비교 정렬'이며 정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지 않기 때문에 '제자리 정렬'이기도 하다.
정확히는 데이터를 서로 교환하는 과정에서 임시 변수를 필요로 하나, 이는 충분히 무시할 만큼 적은 양이기 때문에 제자리 정렬로 본다. 이는 선택정렬과도 같은 부분이다.

- 정렬 방법(오름차순)
  - 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들을 비교한다.(첫 번째 타켓은 두번째 원소부터 시작한다.)
  - 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.
  - 그 다음 타겟으 찾아 위와 같은 방법으로 반복한다.

```java
  public class Insertion_Sort {
    public static void insertion_sort(int[] a){
        insertion_sort(a, a.length);
    }
    
    private static void insertion_sort(int[] a, int size) {
        for (int i =1; i<size; i++) {
            int target = a[i];
            
            int j = j -1;
            
            while (j >= 0 && target < a[j]) {
                a[j+1] = a[j];
                j--;
            }
            
            a[j+1] = target;
        }
    }
}

```

- 삽입 정렬의 장점 및 단점

[장점]
1. 추가적인 메모리 소비가 작다.
2. 거의 정렬 된 경우 매우 효율적이다. 즉, 최선의 경우 O(N)의 시간복잡도를 갖는다.
3. 안장정렬이 가능하다

[단점]
1. 역순에 가까울 수록 매우 비효율적이다. 즉, 최악의 경우 O(N 제곱)의 시간복잡도를 갖는다.
2. 데이터의 상태에 따라서 성능 편차가 매우 크다.



## 셸정렬